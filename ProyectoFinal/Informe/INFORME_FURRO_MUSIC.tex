\documentclass[corference]{IEEEtran}
\usepackage[utf8]{inputenc} % Define la codificación del archivo
\usepackage{titling}
\usepackage{hyphenat} 
\usepackage[spanish]{babel}
% Usar Times New Roman con pdfLaTeX
\usepackage{mathptmx}
\usepackage{tocloft} % Para el índice
\usepackage{geometry}
\geometry{margin=1in,paperwidth=595pt,paperheight=841pt} % Márgenes seguros
% Paquetes adicionales
\usepackage{amsmath}
\usepackage{listings}
\usepackage{listingsutf8}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{setspace}
\usepackage{enumitem} 

% Definición de colores para el código
\definecolor{codebg}{rgb}{0.95,0.95,0.95}      % Fondo gris claro
\definecolor{codeframe}{rgb}{0,0,0}      % Color del borde
\definecolor{keyword}{rgb}{0.13,0.55,0.13}     % Verde oscuro para palabras clave
\definecolor{comment}{rgb}{0.5,0.5,0.5}        % Gris para comentarios
\definecolor{string}{rgb}{0.58,0,0.83}         % Púrpura para cadenas
\definecolor{variable}{rgb}{0,0,1}             % Azul para variables
\definecolor{operator}{rgb}{0.75,0,0.75}       % Magenta para operadores

\lstdefinestyle{mystyle}{
    inputencoding=utf8,
    extendedchars=true,
    literate={ñ}{{\~n}}1
             {Ñ}{{\~N}}1
             {á}{{\'a}}1
             {é}{{\'e}}1
             {í}{{\'i}}1
             {ó}{{\'o}}1
             {ú}{{\'u}}1
             {Á}{{\'A}}1
             {É}{{\'E}}1
             {Í}{{\'I}}1
             {Ó}{{\'O}}1
             {Ú}{{\'U}}1,
    backgroundcolor=\color{codebg},         
    keywordstyle=\color{keyword}\bfseries, 
    commentstyle=\color{comment}\itshape,  
    stringstyle=\color{string},            
    identifierstyle=\color{variable},      
    basicstyle=\ttfamily\footnotesize,    
    breaklines=true,                       
    numbers=left,                          
    numberstyle=\tiny\color{codeframe},    
    frame=single,                          
    rulecolor=\color{codeframe},           
    captionpos=b,                          
    showstringspaces=false,                
    tabsize=4,                             
    xleftmargin=10pt,
    numbersep=5pt,
    breaklines=true,         
    breakatwhitespace=true, 
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
}



% Documento
\begin{document}
\sloppy
\setlength{\columnsep}{16pt} % Modifica este valor para personalizar
\begin{titlepage}   
    % Apartado para configurar interlineado
    \setstretch{1.4} % Cambiar a 1, 1.25, 1.5, 2 para ajustar el interlineado
    
    % Inicio de la carátula
    \begin{center}
        \fontsize{12}{14}\selectfont % Tamaño 12 puntos con interlineado 14
        \textbf{“Año del Bicentenario, de la consolidación de nuestra Independencia, \\
        y de la conmemoración de las heroicas batallas de Junín y Ayacucho”}
        
        \includegraphics[width=0.4\textwidth]{LaSalle.jpg}\\
    
        
        \textbf{CARRERA: INGENIERÍA DE SOFTWARE} \\
        \textbf{REPRODUCTOR DE MÚSICA PROGRAMADO EN LENGUAJE C Y C++} \\
        \textbf{ESTRUCTURA DE DATOS} \\
        
        \vspace{1cm}
        
        \textbf{ESTUDIANTES:} \\
        
        \vspace{1cm}
        
        \textbf{Ortiz Castañeda Jorge Luis} \\
        \textbf{Huamani Huamani Jhordan Steven Octavio (No hace nada)} \\
        \textbf{Flores Leon Miguel Angel} \\

        \vspace{1cm}
        
        \textbf{DOCENTE:} \\
        \textbf{Luque Mamani Edson Fracisco} \\

        \vspace{1cm}
        
        \textbf{Arequipa, Perú} \\
        \textbf{30 de noviembre de 2024}
    \end{center}
    \end{titlepage}
    % Fin de la carátula
    \newpage
    \newpage
    
    \renewcommand{\contentsname}{}
    
    \begin{center}
        \textbf{\huge Índice} % Título del índice centrado y en negrita
    \end{center}
    
    \tableofcontents
    
    \newpage
    \setlength{\parindent}{4em}
    \newpage
    \begin{flushleft}
        \section{Introducción}
        \noindent\hspace*{4em}En este informe se presenta el desarrollo de una aplicación para un reproductor de música, implementada utilizando los lenguajes de programación C y C++, con la interfaz gráfica desarrollada mediante el framework Qt. El objetivo principal de la aplicación es proporcionar una experiencia de usuario intuitiva y fluida, facilitando la reproducción, búsqueda y gestión de canciones en un entorno de fácil acceso. La aplicación incorpora las funciones fundamentales basadas en la metodología CRUD (Crear, Leer, Actualizar y Eliminar), que es esencial para la manipulación y gestión de los datos de las canciones. Mediante este enfoque, el sistema permite al usuario agregar nuevas canciones a la biblioteca, leer la información almacenada, actualizar los detalles de las canciones existentes y eliminar aquellas que ya no sean necesarias.\\
    
        \noindent\hspace*{4em}Además de estas funcionalidades básicas, se ha integrado un sistema de búsqueda avanzada, que permite a los usuarios encontrar canciones de manera eficiente utilizando diversos criterios, tales como año de lanzamiento, género musical, autor, o incluso palabras clave dentro de los metadatos de las canciones. Esta funcionalidad proporciona una experiencia más personalizada y rápida al gestionar grandes colecciones de música.\\
    
        \noindent\hspace*{4em}Para la organización interna de los datos, hemos optado por utilizar listas enlazadas como estructura de datos principal. Esta elección se debe a su flexibilidad, eficiencia y facilidad de implementación en C y C++. Las listas enlazadas permiten un manejo eficiente de la memoria y proporcionan un rendimiento óptimo al manipular datos de tamaño variable, lo que resulta especialmente útil cuando se gestionan grandes cantidades de canciones.\\
    
        \noindent\hspace*{4em}La interfaz gráfica de usuario (GUI) ha sido desarrollada utilizando Qt, un framework de desarrollo de aplicaciones multiplataforma, lo que permite que la aplicación sea compatible con diferentes sistemas operativos sin necesidad de modificaciones significativas. Qt proporciona herramientas poderosas para crear interfaces intuitivas, y su integración con C++ facilita la creación de una aplicación robusta y eficiente.\\
    
        \newpage
        
        \section{¿Por qué utilizar Linked List?}
        \noindent\hspace*{4em}Aunque la estructura actual del proyecto se basa en árboles B, en las primeras etapas consideramos utilizar listas enlazadas debido a su facilidad de implementación y a la mayor legibilidad que ofrecen durante el proceso de revisión y difusión del código.\\
        \noindent\hspace*{4em}En este sentido, el uso de listas enlazadas nos permitió implementar una lógica básica que facilitó la comprensión de la complejidad involucrada en el manejo de miles o millones de datos provenientes de un archivo CSV (separado por comas).
        
        \section{Hablemos de los BTree}
        \noindent\hspace*{4em}Los B-trees son una estructura de datos auto-equilibrada que garantiza búsquedas, inserciones y eliminaciones eficientes. Están diseñados específicamente para manejar grandes volúmenes de datos y optimizar el acceso en memoria secundaria como discos. Cada nodo en un B-tree puede contener múltiples claves, lo que reduce la profundidad del árbol y minimiza los accesos necesarios para realizar operaciones. Una ventaja clave sobre las listas enlazadas es su tiempo de búsqueda de \(O(\log n)\), frente al \(O(n)\) de las listas, ya que estas últimas requieren un recorrido secuencial para localizar un elemento.\\

        \section{Utilizando Tries para la Búsquedas}

        \noindent\hspace*{4em}Un trie es una estructura de datos en forma de árbol que se utiliza para almacenar palabras de manera que los prefijos compartidos entre ellas comparten un espacio común en el árbol. Esto hace que sea una opción ideal para realizar búsquedas eficientes basadas en prefijos.

        \noindent\hspace*{4em}Para buscar palabras por su prefijo, primero se construye el trie utilizando todas las palabras del conjunto. A partir de la raíz del trie, se sigue el camino que corresponde a los caracteres del prefijo. Si el prefijo existe en el trie, se identifica el nodo final del prefijo. Desde este nodo, se realiza un recorrido para recopilar todas las palabras completas que tienen dicho prefijo.
        
        \noindent\hspace*{4em}El trie permite realizar búsquedas rápidas y es especialmente útil cuando se trabaja con un gran número de palabras y se necesitan respuestas en tiempo eficiente. Además, aprovecha la estructura jerárquica para minimizar redundancias, ya que los prefijos comunes se almacenan una sola vez.
        
        \section{Utilizando Vectores para accesos inmediatos}

        \section{Uso del Vector para Buscar una Canción Aleatoria}
            \noindent\hspace{4em}Un \textbf{vector} es una estructura de datos secuencial que permite acceder a sus elementos en tiempo constante (\(O(1)\)) mediante índices. Para buscar una canción aleatoria por su nombre:
            \begin{itemize}
                \item Almacenar las canciones en el vector, donde cada entrada contiene los atributos de la canción, incluyendo el nombre.
                \item Para seleccionar una canción aleatoria, generar un índice aleatorio entre \(0\) y el tamaño del vector menos uno (\(n-1\)), y acceder al elemento en esa posición.
                \item Esto es eficiente debido a que tanto el acceso por índice como la generación del índice aleatorio son operaciones rápidas.
            \end{itemize}
        
        \subsection{Aplicación de Paralelismo en el Ordenamiento por Atributo}
            \noindent\hspace*{4em}El ordenamiento de canciones por atributo, como el nombre, el artista o la popularidad, puede optimizarse aplicando técnicas de paralelismo. Este enfoque divide el vector en múltiples subgrupos que se ordenan de manera simultánea en diferentes hilos o procesos. El procedimiento sería:
            \begin{enumerate}
                \item \textbf{División del vector:} El vector se divide en \(k\) subgrupos, donde \(k\) es el número de hilos disponibles. Cada subgrupo contiene una parte igual (o casi igual) de los elementos.
                \item \textbf{Ordenamiento local:} Cada subgrupo es ordenado independientemente utilizando un algoritmo eficiente como Quicksort o Mergesort.
                \item \textbf{Fusión paralela:} Los subgrupos ordenados se combinan en un único vector ordenado mediante un proceso de fusión paralelo, donde los hilos comparan y seleccionan elementos en cada paso.
            \end{enumerate}
        
        \subsection{Ventajas del Paralelismo en Ordenamiento}
            \noindent\hspace*{4em}El uso de paralelismo reduce significativamente el tiempo total de ordenamiento, especialmente en conjuntos de datos grandes. La complejidad se aproxima a \(\frac{O(n \log n)}{k}\), donde \(n\) es el número de canciones y \(k\) el número de hilos. Además, este enfoque escala bien en arquitecturas con múltiples núcleos, aprovechando al máximo los recursos del hardware disponible.
            
            \noindent\hspace*{4em}En resumen, el vector es útil para acceder rápidamente a una canción aleatoria, y el paralelismo permite optimizar procesos intensivos como el ordenamiento por atributo de manera eficiente y escalable.
    
        \section{Explicación del Código para el Backend}
            \subsection{btree.h}
            
            \begin{lstlisting}[language=C, style=mystyle, caption={Cabecera de un Árbol B}]
#ifndef BTREE_H
#define BTREE_H

#include "cancion.h"
#include <vector>
#include <string>

class BTreeNode {
public:
    std::vector<Cancion> keys;
    std::vector<BTreeNode*> children;
    bool isLeaf;
    int t;

    BTreeNode(int t, bool isLeaf);

    void insertNonFull(Cancion k);
    void splitChild(int i, BTreeNode* y);
    void traverse();
    BTreeNode* search(const std::string& key, bool searchByArtist);
    void searchAll(const std::string& key, bool searchByArtist, std::vector<Cancion>& result);

};

class BTree {
public:
    BTreeNode* root;
    int t;

    BTree(int t);

    void traverse();
    BTreeNode* search(const std::string& key, bool searchByArtist);
    void insert(Cancion k);
    void searchAll(const std::string& key, bool searchByArtist, std::vector<Cancion>& result); 
};
    
#endif // BTREE_H
            \end{lstlisting}

            \noindent\hspace*{4em}Este código define las clases necesarias para implementar un \textbf{B-Tree}, una estructura de datos balanceada útil para almacenar grandes conjuntos de datos de manera eficiente. Está dividido en dos partes principales: la clase \textbf{BTreeNode} para los nodos individuales del árbol y la clase \textbf{BTree} para representar el árbol completo.
            
            \subsubsection{Directivas de Preprocesador}
                \noindent\hspace*{4em}El archivo comienza con las directivas de preprocesador \verb|#ifndef|, \verb|#define| y \verb|#endif| para evitar que el archivo de cabecera sea incluido múltiples veces en el programa. Luego, incluye los archivos necesarios: \verb|cancion.h|, que probablemente define la estructura o clase \textbf{Cancion}, y las bibliotecas estándar \textbf{vector} y \textbf{string}.
            
            \subsubsection{Clase BTreeNode}
                \noindent\hspace*{4em}La clase \textbf{BTreeNode} representa un nodo del B-Tree. Contiene:
                
                \begin{itemize}[left=4em]  % Ajuste global para la indentación
                    \item Un vector de objetos \textbf{Cancion} llamado \textbf{keys} que almacena las claves en el nodo.
                    \item Un vector de punteros a nodos \textbf{children} que almacena los hijos del nodo.
                    \item Un booleano \textbf{isLeaf} que indica si el nodo es una hoja.
                    \item Un entero \textbf{t} que representa el grado mínimo del B-Tree.
                \end{itemize}
                
                \noindent\hspace*{4em}Además, la clase \textbf{BTreeNode} incluye varios métodos importantes:
                
                \begin{itemize}[left=4em]  % Ajuste global para la indentación
                    \item \textbf{Constructor}: Inicializa un nodo con el grado mínimo \textbf{t} y un indicador de si es \textbf{hoja}.
                    \item \textbf{insertNonFull}: Inserta una \textbf{clave} en un nodo que no está \textbf{lleno}.
                    \item \textbf{splitChild}: Divide un \textbf{hijo lleno} en dos nodos más \textbf{pequeños}.
                    \item \textbf{traverse}: Recorre y muestra las \textbf{claves} en el nodo y sus \textbf{hijos}.
                    \item \textbf{search}: Busca una \textbf{clave} en el nodo y sus \textbf{descendientes}, con la opción de buscar por \textbf{nombre del artista} (\textbf{searchByArtist}).
                    \item \textbf{searchAll}: Busca todas las \textbf{canciones} que coincidan con un \textbf{criterio} y las almacena en un \textbf{vector de resultados}.
                \end{itemize}

            
            \subsubsection{Clase BTree}
                \noindent\hspace*{4em}La clase \textbf{BTree} representa el \textbf{árbol} en su totalidad. Contiene:
                
                \begin{itemize}[left=4em]  % Ajuste global para la indentación
                    \item Un \textbf{puntero} \textbf{root} que apunta al \textbf{nodo raíz} del \textbf{árbol}.
                    \item Un \textbf{entero} \textbf{t} que especifica el \textbf{grado mínimo} del \textbf{árbol}.
                \end{itemize}
                
                \noindent\hspace*{4em}Sus métodos incluyen:
                
                \begin{itemize}[left=4em]  % Ajuste global para la indentación
                    \item \textbf{Constructor}: Inicializa un \textbf{árbol vacío} con el \textbf{grado mínimo} \textbf{t}.
                    \item \textbf{traverse}: Recorre y muestra todas las \textbf{claves} del \textbf{árbol}.
                    \item \textbf{search}: Busca una \textbf{clave} en todo el \textbf{árbol} utilizando la función correspondiente en los \textbf{nodos}.
                    \item \textbf{insert}: Inserta una \textbf{clave} en el \textbf{árbol}, manejando casos especiales como cuando la \textbf{raíz} está \textbf{llena}.
                    \item \textbf{searchAll}: Realiza una \textbf{búsqueda exhaustiva} en todo el \textbf{árbol} y devuelve los \textbf{resultados coincidentes}.
                \end{itemize}
            
            \subsubsection{Características del B-Tree}
                \noindent\hspace*{4em}Este código utiliza vectores y punteros para manejar la estructura jerárquica del B-Tree, lo que permite una gestión dinámica de memoria y escalabilidad para almacenar claves y nodos. La estructura es adecuada para aplicaciones como bases de datos y sistemas de archivos donde la eficiencia en la búsqueda y actualización de datos es crucial.
                
            \vspace{1cm}
        \subsection{btree.cpp}
            \begin{lstlisting}[language=C++, style=mystyle, caption={Código de un Árbol B}]
#include "btree.h"
#include <iostream>

BTree::BTree(int t) : t(t), root(nullptr) {}

BTreeNode::BTreeNode(int t, bool isLeaf) : t(t), isLeaf(isLeaf) {
    keys.reserve(2 * t - 1);
    children.reserve(2 * t);
}

void BTreeNode::traverse() {
    int i;
    for (i = 0; i < keys.size(); i++) {
        if (!isLeaf) {
            children[i]->traverse();
        }
        keys[i].imprimirDatos();
    }
    if (!isLeaf) {
        children[i]->traverse();
    }
}

BTreeNode* BTreeNode::search(const std::string& key, bool searchByArtist) {
    int i = 0;
    while (i < keys.size() && (searchByArtist ? keys[i].artist_name : keys[i].track_name) < key) {
        i++;
    }

    if (i < keys.size() && (searchByArtist ? keys[i].artist_name : keys[i].track_name) == key) {
        return this;
    }

    if (isLeaf) {
        return nullptr;
    }

    return children[i]->search(key, searchByArtist);
}

void BTreeNode::searchAll(const std::string& key, bool searchByArtist, std::vector<Cancion>& result) {
    int i = 0;
    while (i < keys.size() && (searchByArtist ? keys[i].artist_name : keys[i].track_name) < key) {
        i++;
    }

    if (i < keys.size() && (searchByArtist ? keys[i].artist_name : keys[i].track_name) == key) {
        result.push_back(keys[i]);
    }

    if (isLeaf) {
        return;
    }

    for (int j = 0; j <= keys.size(); j++) {
        children[j]->searchAll(key, searchByArtist, result);
    }
}

void BTree::traverse() {
    if (root != nullptr) {
        root->traverse();
    }
}

BTreeNode* BTree::search(const std::string& key, bool searchByArtist) {
    return (root == nullptr) ? nullptr : root->search(key, searchByArtist);
}

void BTree::searchAll(const std::string& key, bool searchByArtist, std::vector<Cancion>& result) {
    if (root != nullptr) {
        root->searchAll(key, searchByArtist, result);
    }
}

void BTree::insert(Cancion k) {
    if (root == nullptr) {
        root = new BTreeNode(t, true);
        root->keys.push_back(k);
    } else {
        if (root->keys.size() == 2 * t - 1) {
            BTreeNode* s = new BTreeNode(t, false);
            s->children.push_back(root);
            s->splitChild(0, root);

            int i = 0;
            if ((s->keys[0].artist_name < k.artist_name) || (s->keys[0].track_name < k.track_name)) {
                i++;
            }
            s->children[i]->insertNonFull(k);

            root = s;
        } else {
            root->insertNonFull(k);
        }
    }
}

void BTreeNode::insertNonFull(Cancion k) {
    int i = keys.size() - 1;

    if (isLeaf) {
        keys.push_back(k);
        while (i >= 0 && (keys[i].artist_name > k.artist_name || keys[i].track_name > k.track_name)) {
            keys[i + 1] = keys[i];
            i--;
        }
        keys[i + 1] = k;
    } else {
        while (i >= 0 && (keys[i].artist_name > k.artist_name || keys[i].track_name > k.track_name)) {
            i--;
        }
        if (children[i + 1]->keys.size() == 2 * t - 1) {
            splitChild(i + 1, children[i + 1]);
            if ((keys[i + 1].artist_name < k.artist_name) || (keys[i + 1].track_name < k.track_name)) {
                i++;
            }
        }
        children[i + 1]->insertNonFull(k);
    }
}

void BTreeNode::splitChild(int i, BTreeNode* y) {
    BTreeNode* z = new BTreeNode(y->t, y->isLeaf);
    z->keys.assign(y->keys.begin() + t, y->keys.end());
    y->keys.resize(t - 1);

    if (!y->isLeaf) {
        z->children.assign(y->children.begin() + t, y->children.end());
        y->children.resize(t);
    }

    children.insert(children.begin() + i + 1, z);
    keys.insert(keys.begin() + i, y->keys[t - 1]);
}
            \end{lstlisting}

            \noindent\hspace{4em}Este código implementa un \textit{Árbol B} (B-tree), una estructura de datos autoequilibrada que permite realizar operaciones de búsqueda, inserción y eliminación en tiempo logarítmico. Se utiliza comúnmente en bases de datos y sistemas de archivos debido a su eficiencia en la gestión de grandes volúmenes de datos. El código está compuesto por dos clases principales: \textbf{BTree} y \textbf{BTreeNode}. La clase \textbf{BTree} es la estructura de alto nivel que maneja el árbol en su conjunto, mientras que \textbf{BTreeNode} representa un nodo individual del árbol.
            
            \subsubsection{Desarrollando la Clase BTree }
            
                \noindent\hspace{4em}La clase \textbf{BTree} tiene como miembro principal la raíz del árbol (\textbf{root}) y un parámetro \textbf{t} que especifica el orden del árbol. El constructor de \textbf{BTree} toma un valor \textbf{t} como argumento y establece la raíz en \textbf{nullptr}. La clase \textbf{BTree} implementa varias funciones importantes:
                
                \begin{itemize}[left=4em]
                    \item \textbf{traverse}: Recorre el árbol imprimiendo los datos de cada nodo, comenzando desde la raíz. Si el nodo actual no es una hoja, la función recurre a sus hijos antes de imprimir sus claves.
                    \item \textbf{search}: Busca una clave en el árbol. Si la raíz es \textbf{nullptr}, lo que indica que el árbol está vacío, la función retorna \textbf{nullptr}. Si la raíz existe, delega la búsqueda a la función \textbf{search} de los nodos.
                    \item \textbf{searchAll}: Realiza una búsqueda en todo el árbol y recopila todas las instancias de una clave en un vector de resultados, dependiendo del criterio de búsqueda (ya sea por nombre del artista o por nombre de la pista).
                    \item \textbf{insert}: Inserta una nueva canción en el árbol. Si la raíz está vacía, crea un nuevo nodo raíz con la canción, pero si la raíz ya está llena, se divide en dos nodos, y luego se inserta la canción en el nodo adecuado.
                \end{itemize}
            
            \subsubsection{Desarrollando la Clase BTreeNode}
                
                \noindent\hspace{4em}Recordemos que la clase \textbf{BTreeNode} representa un nodo del árbol y contiene varias claves \textbf{keys}, hijos \textbf{children}, y un indicador \textbf{isLeaf} que señala si el nodo es una hoja. Esta clase también tiene funciones importantes para manejar el nodo:
                
                \begin{itemize}[left=4em]
                    \item \textbf{Constructor}: Inicializa el valor de \textbf{t}, establece si el nodo es una hoja y reserva espacio para las claves y los hijos.
                    \item \textbf{traverse}: Recorre el nodo y sus hijos, imprimiendo las claves almacenadas. Si el nodo no es una hoja, también recurre a sus hijos.
                    \item \textbf{search}: Busca una clave dentro del nodo actual, comparando las claves de los nodos hijos. Si la clave se encuentra en el nodo, la función retorna el nodo; de lo contrario, la búsqueda continúa en el hijo correspondiente.
                    \item \textbf{searchAll}: Realiza una búsqueda recursiva para encontrar todas las instancias de una clave en el árbol. Compara la clave con las claves de los nodos hijos y agrega todas las canciones que coinciden en el vector de resultados.
                    \item \textbf{insertNonFull}: Maneja la inserción de una clave en un nodo que no está lleno, asegurándose de que las claves se mantengan ordenadas. Si el nodo no es una hoja, primero recurre al hijo adecuado antes de insertar la clave. Si el nodo es una hoja, la clave se inserta directamente en la posición correcta.
                \end{itemize}
            
            \subsubsection{Función splitChild}
            
                \noindent\hspace*{4em}La función \textbf{splitChild} maneja la división de un nodo lleno. Cuando un nodo tiene más claves de las que puede almacenar (es decir, cuando el número de claves alcanza \textbf{2 * t - 1}), se divide en dos nodos. La clave del medio del nodo original se mueve hacia el nodo padre, y el nodo original se divide en dos partes, creando un nuevo nodo. Si el nodo no es una hoja, los hijos también se dividen.
            
            \subsection{cancion.h}

            \begin{lstlisting}[language=C, style=mystyle, caption={Cabecera de la Clase Canción}]
#ifndef CANCION_H
#define CANCION_H

#include <iostream>
#include <iomanip>
#include <string>

using namespace std;

class Cancion {
public:
    int id;
    string artist_name;
    string track_name;
    string track_id;
    int popularity;
    int year;
    string genre;
    double danceability;
    double energy;
    int key;
    double loudness;
    int mode;
    double speechiness;
    double acousticness;
    double instrumentalness;
    double liveness;
    double valence;
    double tempo;
    int duration_ms;
    int time_signature;

    Cancion() : id(0), popularity(0), year(0), danceability(0.0), energy(0.0), key(0), loudness(0.0), mode(0), speechiness(0.0), acousticness(0.0), instrumentalness(0.0), liveness(0.0), valence(0.0), tempo(0.0), duration_ms(0), time_signature(0) {}

    Cancion(int id, string artist_name, string track_name, string track_id, int popularity, int year,
                 string genre, double danceability, double energy, int key, double loudness, int mode,
                 double speechiness, double acousticness, double instrumentalness, double liveness,
                 double valence, double tempo, int duration_ms, int time_signature);

    void imprimirDatos();
    void reproducirCancion();
};

#endif // CANCION_H
            \end{lstlisting}

            \subsubsection{Introducción}
            
                \noindent\hspace*{4em}Este código define la cabecera de una clase \textbf{Cancion}, que se utiliza para representar una canción con varias propiedades musicales y de análisis de datos. La clase contiene atributos como el nombre del artista, el nombre de la pista, la popularidad, el año de lanzamiento, y diversos parámetros relacionados con las características de la canción, como la danza, energía, tono, entre otros. La cabecera también declara dos funciones principales: \textbf{imprimirDatos} y \textbf{reproducirCancion}.
            
            \subsubsection{Miembros de la clase}
            
                \noindent\hspace*{4em}La clase \textbf{Cancion} tiene varios atributos públicos que representan distintas características de una canción, incluyendo:
                
                \begin{itemize}[left=4em]
                    \item \textbf{id}: Identificador único de la canción.
                    \item \textbf{artist\_name}: Nombre del artista o banda.
                    \item \textbf{track\_name}: Nombre de la pista.
                    \item \textbf{track\_id}: Identificador único de la pista.
                    \item \textbf{popularity}: Popularidad de la canción en una escala.
                    \item \textbf{year}: Año de lanzamiento de la canción.
                    \item \textbf{genre}: Género musical de la canción.
                    \item \textbf{danceability}: Índice de cuán fácil es bailar al ritmo de la canción.
                    \item \textbf{energy}: Nivel de energía de la canción.
                    \item \textbf{key}: Tono musical de la canción.
                    \item \textbf{loudness}: Volumen de la canción en decibelios.
                    \item \textbf{mode}: Modalidad de la canción (mayor o menor).
                    \item \textbf{speechiness}: Proporción de habla en la canción.
                    \item \textbf{acousticness}: Nivel de acusticidad de la canción.
                    \item \textbf{instrumentalness}: Porcentaje de la canción que es instrumental.
                    \item \textbf{liveness}: Proporción de audibilidad en un contexto en vivo.
                    \item \textbf{valence}: Indicador del estado de ánimo de la canción.
                    \item \textbf{tempo}: Tempo de la canción en beats por minuto.
                    \item \textbf{duration\_ms}: Duración de la canción en milisegundos.
                    \item \textbf{time\_signature}: Firma temporal de la canción (por ejemplo, 4/4).
                \end{itemize}
            
            \subsubsection{Constructores}
            
                \noindent\hspace*{4em}La clase \textbf{Cancion} tiene dos constructores:
                
                \begin{itemize}[left=4em]
                    \item \textbf{Cancion()}: Constructor por defecto que inicializa todos los atributos con valores predeterminados. 
                    \item \textbf{Cancion(int id, string artist\_name, string track\_name, string track\_id, int popularity, int year, string genre, double danceability, double energy, int key, double loudness, int mode, double speechiness, double acousticness, double instrumentalness, double liveness, double valence, double tempo, int duration\_ms, int time\_signature)}: Constructor que recibe parámetros específicos para inicializar los atributos de la canción con valores definidos al crear una instancia de la clase.
                \end{itemize}
            
            \subsubsection{Funciones}
            
                \noindent\hspace*{4em}La clase \textbf{Cancion} declara las siguientes funciones:
                
                \begin{itemize}[left=4em]
                    \item \textbf{imprimirDatos()}: Función miembro que probablemente se encargará de imprimir la información de la canción en un formato legible.
                    \item \textbf{reproducirCancion()}: Función miembro que probablemente se utilizará para reproducir la canción, aunque la implementación no está incluida en esta cabecera.
                \end{itemize}
            
            \subsubsection{Conclusión}
            
            \noindent\hspace*{4em}La clase \textbf{Cancion} está diseñada para encapsular una serie de propiedades que describen una canción y sus características relacionadas. Esta estructura es útil para representar canciones en una aplicación o base de datos que maneje información musical, permitiendo fácilmente la manipulación y presentación de datos musicales.
            \subsection{cancion.cpp}
            \begin{lstlisting}[language=C++, style=mystyle, caption={Código de un Clase Canción}]
#include "cancion.h"

Cancion::Cancion(int id, string artist_name, string track_name, string track_id, int popularity, int year,
                 string genre, double danceability, double energy, int key, double loudness, int mode,
                 double speechiness, double acousticness, double instrumentalness, double liveness,
                 double valence, double tempo, int duration_ms, int time_signature)
    : id(id), artist_name(artist_name), track_name(track_name), track_id(track_id), popularity(popularity),
      year(year), genre(genre), danceability(danceability), energy(energy), key(key), loudness(loudness),
      mode(mode), speechiness(speechiness), acousticness(acousticness), instrumentalness(instrumentalness),
      liveness(liveness), valence(valence), tempo(tempo), duration_ms(duration_ms), time_signature(time_signature) {}

void Cancion::imprimirDatos() {
    cout << "|" << setw(5) << this->id
         << "|" << setw(30) << this->artist_name
         << "|" << setw(30) << this->track_name
         << "|" << setw(30) << this->track_id
         << "|" << setw(5) << this->popularity
         << "|" << setw(5) << this->year
         << "|" << setw(10) << this->genre
         << "|" << setw(5) << this->danceability
         << "|" << setw(5) << this->energy
         << "|" << setw(5) << this->key
         << "|" << setw(5) << this->loudness
         << "|" << setw(5) << this->mode
         << "|" << setw(5) << this->speechiness
         << "|" << setw(5) << this->acousticness
         << "|" << setw(5) << this->instrumentalness
         << "|" << setw(5) << this->liveness
         << "|" << setw(5) << this->valence
         << "|" << setw(5) << this->tempo
         << "|" << setw(5) << this->duration_ms
         << "|" << setw(5) << this->time_signature
         << "|" << endl;
}

void Cancion::reproducirCancion() {
    cout << "Reproduciendo: " << this->track_name << " - " << this->artist_name << endl;
}
            \end{lstlisting}

            \subsubsection{Introducción}
            
                \noindent\hspace*{4em}Este código define la cabecera de una clase \textbf{Cancion}, que se utiliza para representar una canción con varias propiedades musicales y de análisis de datos. La clase contiene atributos como el nombre del artista, el nombre de la pista, la popularidad, el año de lanzamiento, y diversos parámetros relacionados con las características de la canción, como la danza, energía, tono, entre otros. La cabecera también declara dos funciones principales: \textbf{imprimirDatos} y \textbf{reproducirCancion}.
            
            \subsubsection{Miembros de la clase}
            
                \noindent\hspace*{4em}La clase \textbf{Cancion} tiene varios atributos públicos que representan distintas características de una canción, incluyendo:
                
                \begin{itemize}[left=4em]
                    \item \textbf{id}: Identificador único de la canción.
                    \item \textbf{artist\_name}: Nombre del artista o banda.
                    \item \textbf{track\_name}: Nombre de la pista.
                    \item \textbf{track\_id}: Identificador único de la pista.
                    \item \textbf{popularity}: Popularidad de la canción en una escala.
                    \item \textbf{year}: Año de lanzamiento de la canción.
                    \item \textbf{genre}: Género musical de la canción.
                    \item \textbf{danceability}: Índice de cuán fácil es bailar al ritmo de la canción.
                    \item \textbf{energy}: Nivel de energía de la canción.
                    \item \textbf{key}: Tono musical de la canción.
                    \item \textbf{loudness}: Volumen de la canción en decibelios.
                    \item \textbf{mode}: Modalidad de la canción (mayor o menor).
                    \item \textbf{speechiness}: Proporción de habla en la canción.
                    \item \textbf{acousticness}: Nivel de acusticidad de la canción.
                    \item \textbf{instrumentalness}: Porcentaje de la canción que es instrumental.
                    \item \textbf{liveness}: Proporción de audibilidad en un contexto en vivo.
                    \item \textbf{valence}: Indicador del estado de ánimo de la canción.
                    \item \textbf{tempo}: Tempo de la canción en beats por minuto.
                    \item \textbf{duration\_ms}: Duración de la canción en milisegundos.
                    \item \textbf{time\_signature}: Firma temporal de la canción (por ejemplo, 4/4).
                \end{itemize}
            
            \subsubsection{Constructores}
            
                \noindent\hspace*{4em}La clase \textbf{Cancion} tiene dos constructores:
                
                \begin{itemize}[left=4em]
                    \item \textbf{Cancion()}: Constructor por defecto que inicializa todos los atributos con valores predeterminados. 
                    \item \textbf{Cancion(int id, string artist\_name, string track\_name, string track\_id, int popularity, int year, string genre, double danceability, double energy, int key, double loudness, int mode, double speechiness, double acousticness, double instrumentalness, double liveness, double valence, double tempo, int duration\_ms, int time\_signature)}: Constructor que recibe parámetros específicos para inicializar los atributos de la canción con valores definidos al crear una instancia de la clase.
                \end{itemize}
            
            \subsubsection{Funciones}
            
                \noindent\hspace*{4em}La clase \textbf{Cancion} declara las siguientes funciones:
                
                \begin{itemize}[left=4em]
                    \item \textbf{imprimirDatos()}: Función miembro que probablemente se encargará de imprimir la información de la canción en un formato legible.
                    \item \textbf{reproducirCancion()}: Función miembro que probablemente se utilizará para reproducir la canción, aunque la implementación no está incluida en esta cabecera.
                \end{itemize}

            \subsection{playlist.h}

            \begin{lstlisting}[language=C, style=mystyle, caption={Cabecera de la Clase Playlist}]
#ifndef PLAYLIST_H
#define PLAYLIST_H

#include "cancion.h"
#include "btree.h"
#include <vector>
#include <fstream>
#include <sstream>
#include <random>

class PlayList {
public:
    BTree* btree;
    std::vector<Cancion> todasLasCanciones; // Vector para almacenar todas las canciones

    PlayList(int t);
    ~PlayList();

    void agregarCancion(Cancion& cancion);
    vector<Cancion> buscarPorNombre(const std::string& nombre, bool searchByArtist);
    void cargarCSV(const std::string& nombre_archivo);
    void imprimirCanciones();
    void ordenarPorAtributo(const std::string& atributo);
    Cancion reproduccionAleatoria();
    bool actualizarCancion(int id, const Cancion& nuevaCancion);
};

#endif // PLAYLIST_H
            \end{lstlisting}
            \subsubsection{Introducción}
            
                \noindent\hspace*{4em}Este código define la cabecera de la clase \textbf{PlayList}, que gestiona una lista de canciones, almacenando las canciones en un \textit{Árbol B} y un vector. La clase ofrece varias funciones para agregar canciones, buscar canciones por nombre, cargar canciones desde un archivo CSV, imprimir las canciones almacenadas, ordenarlas según un atributo específico, y realizar la reproducción aleatoria de canciones. También incluye una función para actualizar la información de una canción existente.
            
            \subsubsection{Atributos}
            
                \noindent\hspace*{4em}La clase \textbf{PlayList} tiene los siguientes atributos principales:
                
                \begin{itemize}[left=4em]
                    \item \textbf{btree}: Un puntero a un objeto de la clase \textbf{BTree} que organiza las canciones en un árbol para facilitar las búsquedas y otras operaciones.
                    \item \textbf{todasLasCanciones}: Un vector de objetos \textbf{Cancion} que almacena todas las canciones de la lista de reproducción.
                \end{itemize}
            
            \subsubsection{Constructor y Destructor}
            
                \noindent\hspace*{4em}La clase \textbf{PlayList} tiene un constructor y un destructor:
                
                \begin{itemize}[left=4em]
                    \item \textbf{PlayList(int t)}: El constructor toma un parámetro \textbf{t}, que representa el grado mínimo del \textit{Árbol B} (\textbf{BTree}) utilizado para almacenar las canciones. Inicializa el puntero \textbf{btree} y crea el vector \textbf{todasLasCanciones}.
                    \item \textbf{~PlayList()}: El destructor se encarga de liberar cualquier recurso utilizado por la clase, como el puntero \textbf{btree}.
                \end{itemize}
            
            \subsubsection{Funciones}
            
                \noindent\hspace*{4em}La clase \textbf{PlayList} proporciona las siguientes funciones miembros:
                
                \begin{itemize}[left=4em]
                    \item \textbf{agregarCancion(Cancion\& cancion)}: Esta función agrega una canción al vector \textbf{todasLasCanciones} y a la estructura del \textit{Árbol B} (\textbf{btree}).
                    \item \textbf{buscarPorNombre(const std::string\& nombre, bool searchByArtist)}: Permite buscar canciones en la lista de reproducción por nombre, ya sea por el nombre del artista o por el nombre de la pista.
                    \item \textbf{cargarCSV(const std::string\& nombre\_archivo)}: Carga las canciones desde un archivo CSV, parseando el contenido del archivo y agregando las canciones a la lista y al \textit{Árbol B}.
                    \item \textbf{imprimirCanciones()}: Imprime la lista de todas las canciones almacenadas en el vector \textbf{todasLasCanciones}.
                    \item \textbf{ordenarPorAtributo(const std::string\& atributo)}: Ordena las canciones de la lista de reproducción por un atributo específico, como el nombre, la popularidad o el año.
                    \item \textbf{reproduccionAleatoria()}: Devuelve una canción aleatoria de la lista de reproducción.
                    \item \textbf{actualizarCancion(int id, const Cancion\& nuevaCancion)}: Actualiza los detalles de una canción existente, identificada por su \textbf{id}, con la nueva información proporcionada en \textbf{nuevaCancion}.
                \end{itemize}
            
            \subsection{playlist.cpp}
            \begin{lstlisting}[language=C++, style=mystyle, caption={Código de la Clase Playlist}]
// playlist.cpp
#include "playlist.h"
#include <iostream>
#include <algorithm>
#include <execution> 

PlayList::PlayList(int t) {
    btree = new BTree(t);
}

PlayList::~PlayList() {
    delete btree;
}

void PlayList::agregarCancion(Cancion& cancion) {
    btree->insert(cancion);
    todasLasCanciones.push_back(cancion); // Añadir la canción al vector
}

vector<Cancion> PlayList::buscarPorNombre(const std::string& nombre, bool searchByArtist) {
    vector<Cancion> resultados;
    btree->searchAll(nombre, searchByArtist, resultados);
    return resultados;
}

void PlayList::cargarCSV(const std::string& nombre_archivo) {
    ifstream archivo(nombre_archivo);
    if (!archivo.is_open()) {
        cerr << "No se pudo abrir el archivo " << nombre_archivo << endl;
        return;
    }

    string linea;
    getline(archivo, linea);  // Leer la cabecera del CSV
    while (getline(archivo, linea)) {
        stringstream ss(linea);
        string token;

        auto leerCampo = [&ss]() {
            string campo;
            char ch;
            bool dentroComillas = false;

            while (ss.get(ch)) {
                if (ch == '"' && !dentroComillas) {
                    dentroComillas = true;
                } else if (ch == '"' && dentroComillas) {
                    if (ss.peek() == ',') {
                        ss.get();
                        break;
                    }
                    dentroComillas = false;
                } else if (ch == ',' && !dentroComillas) {
                    break;
                } else {
                    campo += ch;
                }
            }
            return campo;
        };

        int id = stoi(leerCampo());
        string artist_name = leerCampo();
        string track_name = leerCampo();
        string track_id = leerCampo();
        int popularity = stoi(leerCampo());
        int year = stoi(leerCampo());
        string genre = leerCampo();
        double danceability = stod(leerCampo());
        double energy = stod(leerCampo());
        int key = stoi(leerCampo());
        double loudness = stod(leerCampo());
        int mode = stoi(leerCampo());
        double speechiness = stod(leerCampo());
        double acousticness = stod(leerCampo());
        double instrumentalness = stod(leerCampo());
        double liveness = stod(leerCampo());
        double valence = stod(leerCampo());
        double tempo = stod(leerCampo());
        int duration_ms = stoi(leerCampo());
        int time_signature = stoi(leerCampo());

        Cancion cancion(id, artist_name, track_name, track_id, popularity, year, genre, danceability, energy, key, loudness, mode, speechiness, acousticness, instrumentalness, liveness, valence, tempo, duration_ms, time_signature);
        agregarCancion(cancion);
    }

    archivo.close();
}

void PlayList::imprimirCanciones() {
    btree->traverse();
}

void PlayList::ordenarPorAtributo(const std::string& atributo) {
    auto comparar = [&atributo](const Cancion& a, const Cancion& b) {
        if (atributo == "popularidad") {
            return a.popularity < b.popularity;
        } else if (atributo == "anio") {
            return a.year < b.year;
        } else if (atributo == "artista") {
            return a.artist_name < b.artist_name;
        } else if (atributo == "cancion") {
            return a.track_name < b.track_name;
        } else if (atributo == "genero") {
            return a.genre < b.genre;
        } else if (atributo == "duracion") {
            return a.duration_ms < b.duration_ms;
        } else if (atributo == "tempo") {
            return a.tempo < b.tempo;
        }
        return false;
    };

    sort(std::execution::par,todasLasCanciones.begin(), todasLasCanciones.end(), comparar);

    cout << "Canciones después de ordenar por " << atributo << ":" << endl;
    for (const auto& cancion : todasLasCanciones) {
        if (atributo == "popularidad") {
            cout << cancion.popularity << " - " << cancion.track_name << endl;
        } else if (atributo == "anio") {
            cout << cancion.year << " - " << cancion.track_name << endl;
        } else if (atributo == "artista") {
            cout << cancion.artist_name << " - " << cancion.track_name << endl;
        } else if (atributo == "cancion") {
            cout << cancion.track_name << endl;
        } else if (atributo == "genero") {
            cout << cancion.genre << " - " << cancion.track_name << endl;
        } else if (atributo == "duracion") {
            cout << cancion.duration_ms << " ms - " << cancion.track_name << endl;
        } else if (atributo == "tempo") {
            cout << cancion.tempo << " - " << cancion.track_name << endl;
        }
    }
}

Cancion PlayList::reproduccionAleatoria() {
    if (todasLasCanciones.empty()) {
        cout << "No hay canciones en la lista de reproducción." << endl;
        return Cancion(); // Devolver una canción por defecto
    }

    static bool seeded = false;
    if (!seeded) {
        srand(time(0));
        seeded = true;
    }

    int indiceAleatorio = rand() % todasLasCanciones.size();
    todasLasCanciones[indiceAleatorio].reproducirCancion();
    return todasLasCanciones[indiceAleatorio];
}

bool PlayList::actualizarCancion(int id, const Cancion& nuevaCancion) {
    for (auto it = todasLasCanciones.begin(); it != todasLasCanciones.end(); ++it) {
        if (it->id == id) {
            *it = nuevaCancion; // Actualizar la canción en el vector
            btree->insert(nuevaCancion); // Insertar la nueva versión de la canción en el B-Tree
            return true;
        }
    }
    return false;
}
            \end{lstlisting}

            \subsubsection{Introducción}

                \noindent\hspace*{4em}Este archivo implementa las funciones definidas en la cabecera \textbf{playlist.h}. Estas funciones gestionan una lista de reproducción de canciones, integrando las funcionalidades de un \textit{Árbol B} (\textbf{BTree}) y un vector para optimizar el almacenamiento y las operaciones de búsqueda, ordenación, carga desde un archivo CSV, y reproducción aleatoria.
                
            \subsubsection{Funciones Implementadas}
            
                \noindent\hspace*{4em}Se explican las funciones de la clase \textbf{PlayList} en detalle:
                
                \begin{itemize}[left=4em]
                
                    \item \textbf{PlayList(int t)}: Constructor que inicializa el puntero \textbf{btree} como un nuevo \textit{Árbol B} de grado \textbf{t}.
                    
                    \item \textbf{\textasciitilde PlayList()}: Destructor que libera la memoria asignada para el \textit{Árbol B} (\textbf{btree}).
                
                    \item \textbf{agregarCancion(Cancion\& cancion)}: Agrega una canción al vector \textbf{todasLasCanciones} y la inserta en el \textit{Árbol B}.
                    
                    \item \textbf{buscarPorNombre(const std::string\& nombre, bool searchByArtist)}: Realiza una búsqueda de canciones en el \textit{Árbol B}, filtrando por nombre de la pista o del artista según el valor de \textbf{searchByArtist}, y devuelve un vector con los resultados.
                
                    \item \textbf{cargarCSV(const std::string\& nombre\_archivo)}: Carga canciones desde un archivo CSV. Lee cada línea, extrae los campos utilizando un método que maneja comillas y separadores, y crea objetos \textbf{Cancion} que se añaden a la lista de reproducción.
                
                    \item \textbf{imprimirCanciones()}: Recorre el \textit{Árbol B} y muestra las canciones almacenadas, aprovechando su capacidad de ordenamiento.
                
                    \item \textbf{ordenarPorAtributo(const std::string\& atributo)}: Ordena las canciones del vector \textbf{todasLasCanciones} según un atributo especificado. La comparación se realiza mediante un \textbf{lambda}, y el ordenamiento se optimiza usando \textbf{std::execution::par} para paralelismo.
                
                    \item \textbf{reproduccionAleatoria()}: Selecciona una canción aleatoria del vector \textbf{todasLasCanciones}, asegurando un comportamiento aleatorio con una semilla única. Si la lista está vacía, retorna un objeto \textbf{Cancion} por defecto.
                
                    \item \textbf{actualizarCancion(int id, const Cancion\& nuevaCancion)}: Busca una canción en el vector por su \textbf{id}. Si la encuentra, la actualiza y la reinserta en el \textit{Árbol B} con los nuevos datos.
                \end{itemize}
            
            \subsubsection{Aspectos Clave}
            
                \begin{itemize}[left=4em]
                
                    \item \textbf{Uso del \textit{Árbol B}}: Optimiza las búsquedas al almacenar las canciones de forma ordenada, permitiendo búsquedas eficientes.
                    
                    \item \textbf{Carga desde CSV}: Maneja correctamente campos con comillas o separadores dentro de los datos, asegurando la integridad de la información cargada.
                    
                    \item \textbf{Ordenamiento Paralelo}: La función de ordenación aprovecha la biblioteca \textbf{std::execution} para realizar operaciones más rápidas en procesadores multinúcleo.
                    
                    \item \textbf{Reproducción Aleatoria}: Utiliza una semilla única para garantizar un comportamiento aleatorio consistente en diferentes ejecuciones.
                    
                    \item \textbf{Actualización de Canciones}: Garantiza que las modificaciones a una canción se reflejen tanto en el vector como en el \textit{Árbol B}, preservando la sincronización de los datos.
                \end{itemize}

            \subsection{trie.h}
                \begin{lstlisting}[language=C, style=mystyle, caption={Cabecera de la Clase Trie}]
#ifndef TRIE_H
#define TRIE_H

#include <iostream>
#include <unordered_map>
#include <string>
#include <vector>

using namespace std;

struct TrieNode {
    unordered_map<char, TrieNode*> children;
    bool isleaf; 

    TrieNode() : isleaf(false) {}
};

class Trie {
public:
    Trie();
    ~Trie();                    
    bool startsWith(const string& prefix); 
    void insert(const string& word);
    void deleteTrie(TrieNode* node);
    vector<string> findWordsWithPrefix(const string& prefix);

private:
    TrieNode* root;
    void findAllWords(TrieNode* node, string currentPrefix, vector<string>& words);
};

#endif
                \end{lstlisting}

                \subsubsection{Librerías incluidas:}
                \begin{itemize}
                    \item \textbf{\textless iostream\textgreater:} Se utiliza para entrada/salida estándar.
                    \item \textbf{\textless unordered\_map\textgreater:} Se utiliza para implementar un mapa hash eficiente.
                    \item \textbf{\textless string\textgreater:} Proporciona soporte para manejar cadenas de texto.
                    \item \textbf{\textless vector\textgreater:} Permite almacenar listas dinámicas de palabras.
                \end{itemize}
                
                \subsubsection{Estructura TrieNode}
                \begin{itemize}
                    \item \textbf{children:} Es un mapa que asocia caracteres (\textbf{char}) con punteros a nodos hijos.
                    \item \textbf{isleaf:} Es un booleano que indica si el nodo representa el final de una palabra.
                    \item \textbf{TrieNode():} Constructor que inicializa \textbf{isleaf} como \textbf{false}.
                \end{itemize}
                
                \subsubsection{Clase Trie}
                \begin{itemize}
                    \item \textbf{Trie():} Constructor que inicializa la raíz del trie.
                    \item \textbf{\textasciitilde Trie():} Destructor para liberar memoria asociada con los nodos del trie.
                    \item \textbf{bool startsWith(const string\& prefix):} Método que verifica si existe alguna palabra en el trie que comience con un prefijo dado.
                    \item \textbf{void insert(const string\& word):} Inserta una nueva palabra en el trie.
                    \item \textbf{void deleteTrie(TrieNode* node):} Libera de forma recursiva la memoria de un nodo y todos sus hijos.
                    \item \textbf{vector\textless string\textgreater findWordsWithPrefix(const string\& prefix):} Encuentra todas las palabras que comienzan con un prefijo dado.
                \end{itemize}
                
                \subsubsection{Miembros privados de la clase Trie:}
                \begin{itemize}
                    \item \textbf{TrieNode* root:} Representa el nodo raíz del trie.
                    \item \textbf{void findAllWords(TrieNode* node, string currentPrefix, vector\textless string\textgreater\& words):} Función auxiliar que encuentra todas las palabras en el subárbol de un nodo dado, añadiéndolas a un vector.
                \end{itemize}
                
                \item \textbf{\#endif:} Marca el final de la directiva de inclusión condicional, completando la protección contra múltiples inclusiones.

            \subsection{trie.cpp}
            
            \begin{lstlisting}[language=C, style=mystyle, caption={Código de la Clase trie}]
#include "Trie.h"

Trie::Trie() {
    root = new TrieNode();  // Crear la raíz del Trie
}

Trie::~Trie() {
    deleteTrie(root);  // Liberar memoria de los nodos del Trie
}

void Trie::deleteTrie(TrieNode* node) {
    for (auto& pair : node->children) {
        deleteTrie(pair.second); 
    }
    delete node;  
}

void Trie::insert(const string& word) {
    TrieNode* node = root;
    for (char c : word) {
        if (node->children.find(c) == node->children.end()) {
            node->children[c] = new TrieNode();
        }
        node = node->children[c];
    }
    node->isleaf = true;
}

vector<string> Trie::findWordsWithPrefix(const string& prefix) {
    TrieNode* node = root;
    vector<string> words;

    for (char c : prefix) {
        if (node->children.find(c) == node->children.end()) {
            return words;  // Prefijo no encontrado
        }
        node = node->children[c];
    }

    findAllWords(node, prefix, words);
    return words;
}

void Trie::findAllWords(TrieNode* node, string currentPrefix, vector<string>& words) {
    if (node->isleaf) {
        words.push_back(currentPrefix);
    }

    for (auto& pair : node->children) {
        findAllWords(pair.second, currentPrefix + pair.first, words);
    }
}
            \end{lstlisting}

            \subsubsection{Constructor y Destructor}
                \begin{itemize}
                    \item \textbf{Trie::Trie():} 
                    \begin{itemize}
                        \item Inicializa un objeto de la clase \textbf{Trie}, creando la raíz del Trie mediante la instrucción \textbf{root = new TrieNode();}.
                    \end{itemize}
                    \item \textbf{Trie::~Trie():} 
                    \begin{itemize}
                        \item Libera toda la memoria utilizada por los nodos del Trie mediante la llamada a la función auxiliar \textbf{deleteTrie(root);}.
                    \end{itemize}
                \end{itemize}
                
            \subsubsection{Función auxiliar deleteTrie(TrieNode* node)}
                \begin{itemize}
                    \item Recorre recursivamente los hijos de un nodo utilizando un bucle \textbf{for (auto\& pair : node->children)}.
                    \item Para cada hijo, se llama a \textbf{deleteTrie(pair.second)}.
                    \item Finalmente, libera la memoria del nodo actual con \textbf{delete node;}.
                \end{itemize}
                
            \subsubsection{Método insert(const string\& word)}
                \begin{itemize}
                    \item Inserta una palabra en el Trie carácter por carácter.
                    \item Utiliza un puntero \textbf{node} que inicialmente apunta a la raíz.
                    \item Para cada carácter \textbf{c} en la palabra:
                    \begin{itemize}
                        \item Si \textbf{node->children.find(c)} no encuentra el carácter, se crea un nuevo nodo para \textbf{c}.
                        \item El puntero \textbf{node} avanza al nodo correspondiente a \textbf{c}.
                    \end{itemize}
                    \item Al final de la palabra, se marca el nodo actual como hoja mediante \textbf{node->isleaf = true}.
                \end{itemize}
                
            \subsubsection{Método findWordsWithPrefix(const string\& prefix)}
                \begin{itemize}
                    \item Encuentra todas las palabras que comienzan con un prefijo dado.
                    \item Inicializa un puntero \textbf{node} apuntando a la raíz y un vector \textbf{words} vacío.
                    \item Recorre los caracteres del prefijo:
                    \begin{itemize}
                        \item Si algún carácter no existe en \textbf{node->children}, retorna el vector vacío.
                        \item Avanza el puntero \textbf{node} al hijo correspondiente al carácter actual.
                    \end{itemize}
                    \item Llama a \textbf{findAllWords(node, prefix, words)} para encontrar todas las palabras en el subárbol.
                    \item Retorna el vector \textbf{words}.
                \end{itemize}
                
            \subsubsection{Función auxiliar findAllWords(TrieNode* node, string currentPrefix, vector<string>\& words)}
                \begin{itemize}
                    \item Realiza una búsqueda en profundidad para recopilar todas las palabras desde un nodo dado.
                    \item Si el nodo es una hoja (\textbf{node->isleaf}), agrega el prefijo actual al vector \textbf{words}.
                    \item Recorre recursivamente todos los hijos del nodo actual:
                    \begin{itemize}
                        \item Llama a \textbf{findAllWords(pair.second, currentPrefix + pair.first, words)} para cada hijo, concatenando el carácter actual al prefijo.
                    \end{itemize}
                \end{itemize}
            
            \subsection{menu.h}
            
            \begin{lstlisting}[language=C, style=mystyle, caption={Cabecera de la Clase Menú}]
#include "playlist.h"
#include <iostream>
#include <chrono>

using namespace std;

class Menu {
public:
    PlayList playlist;
    Menu() : playlist(5) {
        cout << "Inicializando menú y cargando lista de reproducción..." << endl;
    }

    // Destructor
    ~Menu() {
        cout << "Liberando recursos y cerrando el menú..." << endl;
    }
    void lectura_csv();
    void interfaz_menu();
    void menu_busqueda(int numero_opcion);
    void menu_ordenamiento(int numero_opcion);
    void menu_reproduccion_aleatoria(int numero_opcion);
    void menu_impresion(int numero_opcion);
    void menu_actualizar_cancion(int numero_opcion);
};  
            \end{lstlisting}
\end{sloppypar}
            \subsubsection{Clase Menu}
                \begin{itemize}
                    \item \textbf{Propósito:} 
                    \begin{itemize}
                        \item Gestionar la interacción del usuario con una lista de reproducción a través de diversas opciones de menú.
                    \end{itemize}
                \end{itemize}
            
            \subsubsection{Atributos de la clase}
                \begin{itemize}
                    \item \textbf{PlayList playlist:} 
                    \begin{itemize}
                        \item Es una instancia de la clase \textbf{PlayList}.
                        \item Se inicializa con un tamaño de \textbf{5}, tal como se especifica en el constructor de \textbf{Menu}.
                    \end{itemize}
                \end{itemize}
            
            \subsubsection{Constructor Menu()}
                \begin{itemize}
                    \item Inicializa el objeto \textbf{playlist} con un tamaño de \textbf{5}.
                    \item Muestra un mensaje en la consola indicando que el menú se está inicializando y que la lista de reproducción está siendo cargada:
                    \begin{verbatim}
                    Inicializando menú y cargando lista de reproducción...
                    \end{verbatim}
                \end{itemize}
            
            \subsubsection{Destructor  Menu()}
                \begin{itemize}
                    \item Se ejecuta automáticamente cuando el objeto \textbf{Menu} es destruido.
                    \item Libera los recursos utilizados por el menú y muestra el mensaje:
                    \begin{verbatim}
                    Liberando recursos y cerrando el menú...
                    \end{verbatim}
                \end{itemize}
            
            \subsubsection{Métodos públicos}
                \begin{itemize}
                \item \textbf{void lectura\_csv():} 
                \begin{itemize}
                    \item Permite cargar datos desde un archivo CSV para poblar la lista de reproducción.
                \end{itemize}
                \item \textbf{void interfaz\_menu():} 
                \begin{itemize}
                    \item Gestiona la interacción principal con el usuario, mostrando opciones de menú.
                \end{itemize}
                \item \textbf{void menu\_busqueda(int numero\_opcion):} 
                \begin{itemize}
                    \item Permite realizar búsquedas específicas en la lista de reproducción, según la opción seleccionada por el usuario.
                \end{itemize}
                \item \textbf{void menu\_ordenamiento(int numero\_opcion):} 
                \begin{itemize}
                    \item Ofrece opciones para ordenar la lista de reproducción utilizando diferentes criterios.
                \end{itemize}
                \item \textbf{void menu\_reproduccion\_aleatoria(int numero\_opcion):} 
                \begin{itemize}
                    \item Permite reproducir canciones de forma aleatoria, basándose en la opción seleccionada.
                \end{itemize}
                \item \textbf{void menu\_impresion(int numero\_opcion):} 
                \begin{itemize}
                    \item Imprime información de la lista de reproducción según los criterios establecidos.
                \end{itemize}
                \item \textbf{void menu\_actualizar\_cancion(int numero\_opcion):} 
                \begin{itemize}
                    \item Ofrece opciones para actualizar los datos de una canción específica en la lista de reproducción.
                \end{itemize}
            \end{itemize}

            \subsection{menu.cpp}
            
            \begin{sloppypar}
            \begin{lstlisting}[language=C++, style=mystyle, caption={Cabecera de la Clase Menú}]
#include "menu.h"
#include <iostream>

//menú principal

void Menu::lectura_csv(){
    // =============================== LECTURA DEL CSV ===============================
    cout << "Leyendo datos desde archivo CSV..." << endl;
    auto inicioLectura = chrono::high_resolution_clock::now();
    
    playlist.cargarCSV("Pruebas.csv");

    auto finLectura = chrono::high_resolution_clock::now();
    auto duracionLectura = chrono::duration_cast<chrono::seconds>(finLectura - inicioLectura).count();
    cout << "Archivo cargado en " << duracionLectura << " segundos." << endl; 
}

void Menu::interfaz_menu() {
    int numero_opcion = 0;
    Menu::lectura_csv();
    // Bucle infinito para mantener el menú en ejecución hasta que el usuario elija salir
    while (numero_opcion != 5) {
        cout << "\nSeleccione una opción: " << endl;
        cout << "[1] Búsqueda" << endl;
        cout << "[2] Ordenamiento" << endl;
        cout << "[3] Reproducción Aleatoria" << endl;
        cout << "[4] Impresión" << endl;
        cout << "[5] Salir \n>> ";  // Opción para salir
        cin >> numero_opcion;
        cout << "\n";
        // Ejecuta la acción según la opción seleccionada
        if (numero_opcion == 1) {
            menu_busqueda(numero_opcion);
        }
        else if (numero_opcion == 2) {
            menu_ordenamiento(numero_opcion);
        }
        else if (numero_opcion == 3) {
            menu_reproduccion_aleatoria(numero_opcion);
        }
        else if (numero_opcion == 4) {
            playlist.imprimirCanciones();
        }
        else if (numero_opcion == 5) {
            cout << "Saliendo del menú..." << endl;
            break;  // Sale del bucle y termina el programa
        }
        else {
            cout << "Opción no válida." << endl;
        }
    }
}

void Menu::menu_busqueda(int numero_opcion) {
    cout << "Seleccione un tipo de Búsqueda: " << endl;
    cout << "[1] Por Nombre de Canción" << endl;
    cout << "[2] Por Nombre de Artista" << endl;
    cout << "[3] Salir" << endl;
    cin >> numero_opcion;

    string nombreBusqueda;
    vector<Cancion> resultados;

    switch (numero_opcion) {
        case 1:
            cout << "Ingrese el prefijo del nombre de la canción: ";
            cin.ignore();
            getline(cin, nombreBusqueda);
            {
                vector<string> canciones = playlist.cancionesTrie.findWordsWithPrefix(nombreBusqueda);
                if (!canciones.empty()) {
                    cout << "Canciones encontradas con el prefijo '" << nombreBusqueda << "':\n";
                    for (size_t i = 0; i < canciones.size(); ++i) {
                        cout << "[" << i + 1 << "] " << canciones[i] << endl;
                    }
                    cout << "Seleccione el número de la canción que desea buscar: ";
                    int seleccion;
                    cin >> seleccion;
                    if (seleccion > 0 && seleccion <= canciones.size()) {
                        nombreBusqueda = canciones[seleccion - 1];
                        resultados = playlist.buscarPorNombre(nombreBusqueda, false);
                        if (!resultados.empty()) {
                            for (auto& cancion : resultados) {
                                cancion.imprimirDatos();
                            }
                        } else {
                            cout << "No se encontró ninguna canción con el nombre " << nombreBusqueda << ".\n";
                        }
                    } else {
                        cout << "Selección no válida.\n";
                    }
                } else {
                    cout << "No se encontró ninguna canción con el prefijo " << nombreBusqueda << ".\n";
                }
            }
            break;
        case 2:
            cout << "Ingrese el prefijo del nombre del artista: ";
            cin.ignore();
            getline(cin, nombreBusqueda);
            {
                vector<string> artistas = playlist.artistasTrie.findWordsWithPrefix(nombreBusqueda);
                if (!artistas.empty()) {
                    cout << "Artistas encontrados con el prefijo '" << nombreBusqueda << "':\n";
                    for (size_t i = 0; i < artistas.size(); ++i) {
                        cout << "[" << i + 1 << "] " << artistas[i] << endl;
                    }
                    cout << "Seleccione el número del artista que desea buscar: ";
                    int seleccion;
                    cin >> seleccion;
                    if (seleccion > 0 && seleccion <= artistas.size()) {
                        nombreBusqueda = artistas[seleccion - 1];
                        resultados = playlist.buscarPorNombre(nombreBusqueda, true);
                        if (!resultados.empty()) {
                            for (auto& cancion : resultados) {
                                cancion.imprimirDatos();
                            }
                        } else {
                            cout << "No se encontró ningún artista con el nombre " << nombreBusqueda << ".\n";
                        }
                    } else {
                        cout << "Selección no válida.\n";
                    }
                } else {
                    cout << "No se encontró ningún artista con el prefijo " << nombreBusqueda << ".\n";
                }
            }
            break;
        case 3:
            break;
        default:
            cout << "Opción no válida." << endl;
            break;
    }
}

void Menu::menu_ordenamiento(int numero_opcion) {
    cout << "Seleccione un tipo de Ordenamiento: " << endl;
    cout << "[1] Por Popularidad" << endl;
    cout << "[2] Por Año" << endl;
    cout << "[3] Por Nombre del Artista" << endl;
    cout << "[4] Por Nombre de la Canción" << endl;
    cout << "[5] Por Género" << endl;
    cout << "[6] Por Duración" << endl;
    cout << "[7] Por Tempo" << endl;
    cout << "[8] Salir" << endl;
    cin >> numero_opcion;

    switch (numero_opcion) {
        case 1:
            playlist.ordenarPorAtributo("popularidad");
            break;
        case 2:
            playlist.ordenarPorAtributo("anio");
            break;
        case 3:
            playlist.ordenarPorAtributo("artista");
            break;
        case 4:
            playlist.ordenarPorAtributo("cancion");
            break;
        case 5:
            playlist.ordenarPorAtributo("genero");
            break;
        case 6:
            playlist.ordenarPorAtributo("duracion");
            break;
        case 7:
            playlist.ordenarPorAtributo("tempo");
            break;
        case 8:
            break;
        default:
            cout << "Opción no válida." << endl;
            break;
    }
}

void Menu::menu_reproduccion_aleatoria(int numero_opcion){
    // =============================== REPRODUCCIÓN ALEATORIA ===============================
    cout << "\nReproduciendo canción aleatoria..." << endl;
    playlist.reproduccionAleatoria();
} 

void Menu::menu_actualizar_cancion(int numero_opcion) {
    int idActualizacion;
    cout << "Ingrese el ID de la canción a actualizar: ";
    cin >> idActualizacion;

    BTreeNode* nodo = playlist.btree->search(to_string(idActualizacion), false);
    Cancion* cancion = nullptr;

    if (nodo) {
        for (auto& c : nodo->keys) {
            if (c.id == idActualizacion) {
                cancion = &c;
                break;
            }
        }
    }

    if (!cancion) {
        cout << "No se encontró una canción con el ID " << idActualizacion << " para actualizar.\n";
        return;
    }

    int opcion;
    do {
        cout << "\nSeleccione el atributo a modificar: " << endl;
        cout << "[1] Nombre del Artista" << endl;
        cout << "[2] Nombre de la Canción" << endl;
        cout << "[3] ID del Track" << endl;
        cout << "[4] Popularidad" << endl;
        cout << "[5] Año" << endl;
        cout << "[6] Género" << endl;
        cout << "[7] Danceability" << endl;
        cout << "[8] Energy" << endl;
        cout << "[9] Key" << endl;
        cout << "[10] Loudness" << endl;
        cout << "[11] Mode" << endl;
        cout << "[12] Speechiness" << endl;
        cout << "[13] Acousticness" << endl;
        cout << "[14] Instrumentalness" << endl;
        cout << "[15] Liveness" << endl;
        cout << "[16] Valence" << endl;
        cout << "[17] Tempo" << endl;
        cout << "[18] Duración en ms" << endl;
        cout << "[19] Time Signature" << endl;
        cout << "[20] Salir" << endl;
        cout << ">> ";
        cin >> opcion;

        switch (opcion) {
            case 1:
                cout << "Ingrese el nuevo nombre del artista: ";
                cin.ignore();
                getline(cin, cancion->artist_name);
                break;
            case 2:
                cout << "Ingrese el nuevo nombre de la canción: ";
                cin.ignore();
                getline(cin, cancion->track_name);
                break;
            case 3:
                cout << "Ingrese el nuevo ID del track: ";
                cin.ignore();
                getline(cin, cancion->track_id);
                break;
            case 4:
                cout << "Ingrese la nueva popularidad: ";
                cin >> cancion->popularity;
                break;
            case 5:
                cout << "Ingrese el nuevo año: ";
                cin >> cancion->year;
                break;
            case 6:
                cout << "Ingrese el nuevo género: ";
                cin.ignore();
                getline(cin, cancion->genre);
                break;
            case 7:
                cout << "Ingrese la nueva danceability: ";
                cin >> cancion->danceability;
                break;
            case 8:
                cout << "Ingrese la nueva energy: ";
                cin >> cancion->energy;
                break;
            case 9:
                cout << "Ingrese el nuevo key: ";
                cin >> cancion->key;
                break;
            case 10:
                cout << "Ingrese el nuevo loudness: ";
                cin >> cancion->loudness;
                break;
            case 11:
                cout << "Ingrese el nuevo mode: ";
                cin >> cancion->mode;
                break;
            case 12:
                cout << "Ingrese la nueva speechiness: ";
                cin >> cancion->speechiness;
                break;
            case 13:
                cout << "Ingrese la nueva acousticness: ";
                cin >> cancion->acousticness;
                break;
            case 14:
                cout << "Ingrese la nueva instrumentalness: ";
                cin >> cancion->instrumentalness;
                break;
            case 15:
                cout << "Ingrese la nueva liveness: ";
                cin >> cancion->liveness;
                break;
            case 16:
                cout << "Ingrese la nueva valence: ";
                cin >> cancion->valence;
                break;
            case 17:
                cout << "Ingrese el nuevo tempo: ";
                cin >> cancion->tempo;
                break;
            case 18:
                cout << "Ingrese la nueva duración en ms: ";
                cin >> cancion->duration_ms;
                break;
            case 19:
                cout << "Ingrese el nuevo time signature: ";
                cin >> cancion->time_signature;
                break;
            case 20:
                cout << "Saliendo de la actualización de canción..." << endl;
                break;
            default:
                cout << "Opción no válida." << endl;
                break;
        }
    } while (opcion != 20);

    cout << "Canción actualizada:\n";
    cancion->imprimirDatos();
}
            \end{lstlisting}
            \end{sloppypar}

            \subsubsection{Clase Menu}
                \begin{itemize}
                    \item \textbf{Propósito:} 
                    \begin{itemize}
                        \item Gestionar las interacciones del usuario mediante un menú principal, ofreciendo funcionalidades relacionadas con una lista de reproducción musical.
                    \end{itemize}
                \end{itemize}
            \subsubsection{Métodos de la clase}
                \begin{itemize}
                    \item \textbf{void lectura\_csv()}
                    \begin{itemize}
                        \item \textbf{Propósito:} 
                        Cargar datos desde un archivo \texttt{CSV} en la lista de reproducción.
                        \item \textbf{Descripción:} 
                        \begin{itemize}
                            \item Muestra un mensaje indicando que la lectura del archivo está en proceso.
                            \item Registra el tiempo de inicio y finalización de la operación.
                            \item Utiliza el método \texttt{cargarCSV} del objeto \texttt{playlist} para procesar el archivo \texttt{"Pruebas.csv"}.
                            \item Calcula y muestra la duración total de la carga en segundos.
                        \end{itemize}
                    \end{itemize}
                \item \textbf{void interfaz\_menu()}
                \begin{itemize}
                    \item \textbf{Propósito:} 
                    Proveer una interfaz interactiva para el usuario.
                    \item \textbf{Descripción:} 
                    \begin{itemize}
                        \item Llama al método \texttt{lectura\_csv()} para cargar datos al inicio.
                        \item Ofrece un menú con las siguientes opciones:
                        \begin{enumerate}
                            \item Búsqueda.
                            \item Ordenamiento.
                            \item Reproducción aleatoria.
                            \item Impresión de la lista de reproducción.
                            \item Salir.
                        \end{enumerate}
                        \item Ejecuta el método correspondiente según la opción seleccionada.
                        \item Valida entradas no válidas y muestra un mensaje de error en caso necesario.
                    \end{itemize}
                \end{itemize}
            
                \item \textbf{void menu\_busqueda(int numero\_opcion)}
                \begin{itemize}
                    \item \textbf{Propósito:} 
                    Buscar canciones o artistas en la lista de reproducción.
                    \item \textbf{Descripción:} 
                    \begin{itemize}
                        \item Permite elegir entre búsqueda por:
                        \begin{itemize}
                            \item Nombre de la canción.
                            \item Nombre del artista.
                        \end{itemize}
                        \item Solicita un prefijo para realizar la búsqueda.
                        \item Muestra los resultados encontrados usando los \texttt{Trie} de canciones o artistas.
                        \item Permite seleccionar un resultado específico para obtener más detalles.
                    \end{itemize}
                \end{itemize}
            
                \item \textbf{void menu\_ordenamiento(int numero\_opcion)}
                \begin{itemize}
                    \item \textbf{Propósito:} 
                    Ordenar la lista de reproducción por diferentes atributos.
                    \item \textbf{Descripción:} 
                    \begin{itemize}
                        \item Ofrece una lista de atributos por los cuales se puede ordenar, como:
                        \texttt{popularidad}, \texttt{año}, \texttt{género}, \texttt{duración}, entre otros.
                        \item Llama al método \texttt{ordenarPorAtributo} del objeto \texttt{playlist} con el atributo seleccionado.
                    \end{itemize}
                \end{itemize}
            
                \item \textbf{void menu\_reproduccion\_aleatoria(int numero\_opcion)}
                \begin{itemize}
                    \item \textbf{Propósito:} 
                    Reproducir canciones de manera aleatoria.
                    \item \textbf{Descripción:} 
                    \begin{itemize}
                        \item Llama al método \texttt{reproduccionAleatoria} del objeto \texttt{playlist}.
                        \item Muestra un mensaje indicando que una canción está siendo reproducida aleatoriamente.
                    \end{itemize}
                \end{itemize}
            
                \item \textbf{void menu\_actualizar\_cancion(int numero\_opcion)}
                \begin{itemize}
                    \item \textbf{Propósito:} 
                    Permitir al usuario actualizar los datos de una canción específica.
                    \item \textbf{Descripción:} 
                    \begin{itemize}
                        \item Solicita al usuario el \texttt{ID} de la canción a actualizar.
                        \item Utiliza el \texttt{BTree} de \texttt{playlist} para buscar la canción correspondiente.
                        \item Ofrece un submenú con una lista de atributos editables:
                        \begin{itemize}
                            \item Ejemplo de atributos: \texttt{nombre del artista}, \texttt{popularidad}, \texttt{género}, \texttt{duración en ms}, entre otros.
                        \end{itemize}
                        \item Actualiza el atributo seleccionado con el nuevo valor proporcionado por el usuario.
                        \item Imprime los datos de la canción actualizada al finalizar.
                    \end{itemize}
                \end{itemize}
            \end{itemize}

            \subsection{main.cpp}

            \begin{lstlisting}[language=C++, style=mystyle, caption={Código del main}]
#include "menu.h"
#include <iostream>
using namespace std;

int main() {
    Menu menu;
    menu.interfaz_menu();
    return 0;
}
            \end{lstlisting}

        \noindent\hspace*{4em}Este archivo contiene la función \textbf{main}, el punto de entrada de la aplicación. Esencialmente, su propósito es inicializar el menú principal e invocar la interfaz interactiva para que el usuario pueda gestionar la lista de reproducción de canciones.

        \subsubsection{Descripción de la Función \texttt{main}}
        
            \begin{itemize}[left=4em]
                \item \textbf{Inicialización del Objeto Menu}: 
                \begin{itemize}
                    \item Se crea un objeto de la clase \textbf{Menu}, definido en el archivo \textbf{menu.h}.
                    \item Este objeto representa la lógica de interacción con el usuario y contiene las funcionalidades necesarias para navegar por el programa.
                \end{itemize}
            
                \item \textbf{Llamada a \texttt{interfaz\_menu()}}:
                \begin{itemize}
                    \item La función \texttt{interfaz\_menu()} es invocada sobre el objeto \textbf{menu}.
                    \item Su objetivo es presentar las opciones del programa al usuario y gestionar las entradas para realizar acciones como agregar canciones, buscar, ordenar, o reproducir aleatoriamente.
                \end{itemize}
            
                \item \textbf{Terminación del Programa}:
                \begin{itemize}
                    \item La función retorna 0 al sistema operativo, indicando que la ejecución del programa se realizó exitosamente.
                \end{itemize}
            \end{itemize}
        
        \subsubsection{Aspectos Clave}
        
            \begin{itemize}[left=4em]
                \item \textbf{Modularidad}: La clase \textbf{Menu} encapsula la lógica de interacción con el usuario, separando las responsabilidades de la función \textbf{main}, lo que mejora la claridad y mantenibilidad del código.
                \item \textbf{Punto de Entrada Único}: El uso de una función \textbf{main} simple permite que el programa sea fácil de comprender y extender en el futuro.
            \end{itemize}
                
        \section{Qt Creator: Entorno ideal para nuestro Frontend}
        \noindent\hspace*{4em}Qt Creator es una herramienta destacada para el desarrollo de interfaces de usuario debido a su combinación de características, facilidad de uso y flexibilidad. Proporciona un entorno de desarrollo integrado (IDE) diseñado específicamente para trabajar con Qt, un marco de trabajo ampliamente utilizado para crear aplicaciones gráficas multiplataforma. Uno de los aspectos más valiosos de Qt Creator es su diseñador visual, que permite a los desarrolladores crear interfaces gráficas de manera intuitiva mediante un sistema de arrastrar y soltar, lo que acelera significativamente el proceso de diseño. Además, las interfaces creadas se integran directamente con el código subyacente, lo que simplifica la conexión entre la lógica de la aplicación y su presentación gráfica.

        \noindent\hspace*{4em}Otra ventaja importante es que Qt Creator soporta múltiples lenguajes de programación, siendo C++ el principal, pero también permite el uso de QML, un lenguaje declarativo diseñado específicamente para interfaces de usuario modernas y fluidas. Esto da a los desarrolladores la capacidad de trabajar con herramientas avanzadas para crear aplicaciones visualmente atractivas y altamente responsivas.

        \noindent\hspace*{4em}La herramienta también se destaca por su capacidad multiplataforma, lo que permite diseñar una interfaz en un sistema operativo y ejecutarla sin cambios en otros como Windows, macOS, Linux, e incluso en dispositivos móviles con Android o iOS. Esto hace que Qt Creator sea ideal para proyectos que necesitan ser distribuidos en múltiples entornos.

        \noindent\hspace*{4em}Otra razón por la que es considerada una buena herramienta es su documentación extensa y su comunidad activa. Esto facilita encontrar soluciones a problemas comunes y aprender a utilizar sus funcionalidades de manera eficiente. Además, Qt Creator incluye características como autocompletado de código, integración con control de versiones, depuración avanzada y herramientas de análisis de rendimiento, que contribuyen a un flujo de trabajo más rápido y eficiente.

        \noindent\hspace*{4em}Por último, su capacidad para manejar proyectos complejos y su compatibilidad con estándares modernos lo convierten en una elección sólida tanto para desarrolladores individuales como para equipos de desarrollo que buscan crear aplicaciones profesionales con interfaces de usuario de alta calidad.

        \subsection{Home de la Interfas de Usuario}
            \includegraphics[width=0.4\textwidth]{iu1.png}
            \noindent\hspace*{4em}La interfaz corresponde a una aplicación con un diseño oscuro y bordes resaltados en azul. En la parte superior, se encuentra un cuadro de texto acompañado por un botón de búsqueda, etiquetado como "Buscar". Adicionalmente, hay una opción seleccionable identificada como "Buscar por artista". 
            
            \noindent\hspace*{4em}En el centro de la interfaz, se presenta un área rectangular grande denominada "Resultados", destinada a mostrar información o listas de elementos. Este espacio está delimitado por un contorno azul.
            
            \noindent\hspace*{4em}Debajo de esta sección principal, hay un menú desplegable titulado "Ordenar por atributo", que parece estar configurado por defecto en "popularidad". A la derecha de este, se encuentra un botón para ejecutar la acción de ordenar.
            
            \noindent\hspace*{4em}Más abajo, hay varios botones y campos de texto. A la izquierda se encuentra el botón "Reproducir Aleatorio", seguido de "Cargar Archivo CSV". Junto a estos, se localizan etiquetas y campos vacíos identificados como "ID", "Nombre", "Artista", "Álbum" y "Duración". A la derecha de estos campos hay un botón llamado "Actualizar".
            
            \noindent\hspace*{4em}El diseño es minimalista y parece orientado a una funcionalidad de gestión de datos o reproducción de música, basado en las etiquetas visibles.

            \noindent\hspace*{4em}En esta nueva versión de la interfaz, se observa que en la sección "Resultados" ahora se muestran datos concretos. Estos datos consisten en una lista numerada de canciones con títulos y, en algunos casos, información adicional. La lista parece estar desplegada completamente, y su contenido sugiere un sistema de gestión o reproducción de música.

        \subsection{Ordenar de la Interfas de Usuario}
            \includegraphics[width=0.4\textwidth]{iu2.png}
            
            \noindent\hspace*{4em}En el menú desplegable "Ordenar por atributo", se nota una ampliación de las opciones disponibles. Ahora, además de "popularidad", se incluyen los siguientes atributos: "año", "artista", "canción", "género", "duración" y "tempo". Esto indica que la funcionalidad de ordenamiento es más versátil y permite organizar la lista de resultados en función de varios criterios.
            
            \noindent\hspace*{4em}La interacción con los resultados y el menú desplegable sugiere una experiencia más dinámica y adaptable a las necesidades del usuario.

        \subsection{Limitación a diez superiores}
            \includegraphics[width=0.4\textwidth]{10.jpg}
            \noindent\hspace*{4em}Aquí solo se muestran los diez primeros con más coincidencia. 
        \subsection{Reproducción Aleatoria}
            \includegraphics[width=0.4\textwidth]{repro.jpg}
            \noindent\hspace*{4em}Aquí tenemos la reproducción aleatoria. 
        \subsection{Búsqueda Óptima}
            \includegraphics[width=0.4\textwidth]{busqueda.jpg}
            \noindent\hspace*{4em}Aquí tenemos la búsqueda exitosa por completación de palabras. 
    \end{flushleft}
    
\end{document}
